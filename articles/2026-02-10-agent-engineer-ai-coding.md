# Agent 工程师，是怎么用 AI 写代码的

> 作者：[yan5xu](https://x.com/yan5xu) · 2026-02-10
> 原文：https://x.com/yan5xu/status/2021162107170095186
> 标签：AI / Article / Develop

**💡 看点：一个做 AI Agent 研发的工程师，把做 agent 系统的思路反过来用在 AI coding 上。HANDOFF 替代 compress 解决上下文丢失，Sub-Agent 拓展上下文窗口，Worktree 隔离并发——三板斧解决 AI 写代码最大的痛点：它记不住事。**

---

## 背景

我的工作是做 AI Agent 研发。日常就是跟 agent 的能力边界打交道——它能做什么、不能做什么、怎么让它做得更好。

2024 年 5 月，Claude 3.5 还没出来的时候，我就开始用 GPT-4 + Dify 自己搭 workflow 写代码了。后来从 Cline 到 Claude Code 再到 OpenCode，一路用过来。我几乎不自己手写代码——不是用 AI 做补全，而是完全交给 agent 来写。不是写 demo、不是跑 benchmark，是真的用它来写生产代码、改 bug、做重构、提 PR。

从 Dify workflow 到现在的 AI coding agent，用了一年多。我发现**最大的坑不是模型不够聪明，而是它记不住事。**

---

## 上下文是 agent 的命脉

做 agent 研发的人都知道，上下文管理是 agent 系统里最核心的问题之一。没有上下文，再强的模型也是无根之木。

AI coding agent 也一样。一个复杂功能做到一半，对话已经很长了。第二天开新会话——它什么都不记得。你得重新描述背景、重新解释决策、重新踩一遍昨天已经趟过的坑。

更糟糕的是 compress。大部分工具在上下文快满时会自动"压缩"对话历史。作为做 agent 的人，我太清楚这意味着什么——**这是不可控的有损压缩。** 关键的设计决策、踩过的坑、中间推理链条，压缩之后大概率丢失。然后 agent 开始重复犯已经解决过的错误。

---

## 用做 agent 的思路来解决它

做 agent 系统时，我们怎么处理这些问题？

- 上下文不够？结构化存储 + 按需加载，关键节点保存状态，下次精确恢复。
- 单个 agent 能力有限？多 agent 协作，主 agent 编排，sub-agent 执行。
- 并发冲突？隔离执行环境，每个任务独立空间，互不干扰。

同样的思路，一一对应到 AI coding agent 上：

### HANDOFF 替代 compress — 解决上下文丢失

在上下文还充足的时候，主动让 agent 写一份结构化的交接文档——已经完成了什么、正在做什么、下一步做什么、有什么坑要注意。然后开新会话，agent 读取 HANDOFF，直接恢复上下文继续工作。

**这不是模糊的"摘要"，而是精确的状态快照。** 信息密度远高于 compress 后的残留。

一个复杂功能做三天，每天换会话，每次 agent 都能从交接文档里精确恢复到昨天的状态。和人类团队的交接逻辑一模一样。

### Sub-Agent 拓展上下文窗口

单个 agent 的上下文是固定的。所有工作都塞在一个对话里——分析代码、写方案、改文件、跑测试——上下文很快就满了。

Sub-Agent 的思路是：**主 agent 只做规划和决策，具体的重活委托给 sub-agent**，结果通过 workspace 文件传回来。主 agent 收到的只是 4 行摘要，但实际完成的工作量可以很大。本质上是用文件系统做信息中转，把单个上下文窗口扩容成了多个。

### Worktree 隔离并发

每个任务在独立的 git worktree 中开发。主仓库始终干净，多个 agent 或多个任务可以并行，不会互相污染代码。做完清理 worktree 就行。

**这三个方案加在一起：HANDOFF 解决时间轴上的连续性，Sub-Agent 解决单次会话的容量限制，Worktree 解决并发隔离。** 都是做 agent 系统时的标准思路。

---

## 人机协作方式变了

用了这套工作流之后，我发现自己跟 AI 的协作方式已经完全不是"在编辑器里跟 AI 对话"了。

传统模式是：你坐在编辑器前面，跟 AI 一行一行地写代码，实时对话，像结对编程。你是操作者，AI 是工具。

现在变成了：你在 Issue 里写需求和验收标准，agent 从 Board 上捡任务，自己开分支、开发、提 PR。你通过 PR review 审查代码。

**这本质上是 tech lead + 开发者的协作模式：**

- 你做架构决策、定优先级、review 代码
- Agent 做具体实现、跑测试、提交 PR
- 通过 Issue 和 PR 沟通，不需要实时盯着
- 多个 agent 可以同时做不同的 Issue，你看 Board 就知道全局进度
- 任何 agent（甚至人类开发者）都可以通过 HANDOFF 接手任何任务

代码审查从"在聊天窗口里看 agent 输出"变成了"在 GitHub PR 界面看 diff、逐行评论、跑 CI"。这是工程团队几十年验证过的流程，比在对话里 review 代码靠谱得多。

---

## 不要只给 agent 一个编辑器

很多人用 AI 写代码就是打开编辑器、对话、写代码。但实际工程里，写代码只是很小一部分。一个真正的开发者还需要：跑测试验证、查线上日志定位问题、查数据库确认数据、用 CLI 部署上线。

**给 agent 自验证的能力。** 搭好本地测试环境，让它能跑单元测试、跑 build、跑 lint、自己确认代码是否正确。不是写完代码就扔给你，而是验证通过了再提交。这一步省掉的来回沟通比你想象的多。

**给 agent 获取信息的能力。** 我给 agent 写了一份日志查询手册，告诉它怎么用 aws logs CLI 查 CloudWatch 日志。Agent 拿着这份手册，自己查了几百个 Pod 的日志，分析出了十几类生产错误，按优先级分级，还自动配了告警规则。整个过程我只做了 review。

**给 agent 完整的 CLI 工具链。** 现在几乎所有云平台都有 CLI——AWS CLI、GCP gcloud、Cloudflare wrangler。Agent 完全可以完成从写代码到部署上线的一条龙操作。

核心思想：**不要把 agent 当成只会写代码的代码生成器，要把它当成一个需要完整工具链的工程师。** 你给它的工具越完整，它需要你介入的次数就越少。

---

## 开源了

这套工作流整理成了一个开源协议叫 **Code Relay**。就是一组 markdown 和 yaml 文件，不是 CLI，不是 SDK。复制到你的项目里就能用。兼容 Cline、Claude Code、OpenCode、Windsurf 等所有主流工具。

两种模式：
- **GitHub 模式** — 任务管理在 Issue + Project Board 上，适合已经用 GitHub 的团队
- **本地文件模式** — 不依赖任何平台，适合离线工作或不想绑定特定平台

如果你也在认真用 AI coding agent 做项目，欢迎试试。

GitHub: https://github.com/yan5xu/code-relay
